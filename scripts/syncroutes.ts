import * as fs from "fs";
import * as path from "path";

const routesPath = "packages/app/routes";
const outPaths = ["apps/next/pages", "apps/expo/app"];
const autoMessage = `/** This file is auto-generated by \`scripts/sync-routes.ts\` */`;

const prefixesToIgnore = /(^_)/;
const extensionsToInclude = /.(tsx|ts|js|jsx)$/;

const routesDir = path.resolve(__dirname, "../", routesPath);
const pagesDirs = outPaths.map((outPath) =>
  path.resolve(__dirname, "../", outPath),
);

// delete all previously auto-generated files and empty folders recursively
pagesDirs.forEach((pagesDir) => {
  const deleteFile = (filePath: string) => {
    if (prefixesToIgnore.test(path.basename(filePath))) return;
    if (!extensionsToInclude.test(path.basename(filePath))) return;
    if (!fs.existsSync(filePath)) return;
    fs.unlinkSync(filePath);
  };

  const deleteEmptyFolder = (folderPath: string) => {
    if (prefixesToIgnore.test(path.basename(folderPath))) return;
    if (fs.readdirSync(folderPath).length === 0) {
      if (fs.existsSync(folderPath)) fs.rmdirSync(folderPath);
    }
  };

  const deleteRecursive = (dirPath: string) => {
    const files = fs.readdirSync(dirPath);
    files.forEach((file) => {
      const filePath = path.resolve(dirPath, file);
      if (!fs.existsSync(filePath)) return;
      if (fs.statSync(filePath).isDirectory()) {
        deleteRecursive(filePath);
      } else {
        deleteFile(filePath);
      }
    });
    deleteEmptyFolder(dirPath);
  };

  deleteRecursive(pagesDir);
});

function generateFileContent(relativePath: string, fileName: string) {
  return [
    autoMessage,
    `export { default } from "@acme/app/routes/${relativePath}/${fileName}";`,
  ].join("\n");
}

function syncRoutes(dir: string, outDirs: string[]) {
  const routes = fs.readdirSync(dir);
  routes.forEach((file) => {
    const filePath = path.resolve(dir, file);

    if (!fs.existsSync(filePath)) return;
    if (fs.statSync(filePath).isDirectory()) {
      // If the file is a directory, call syncRoutes function recursively
      syncRoutes(
        filePath,
        outDirs.map((outDir) => path.resolve(outDir, file)),
      );
    } else {
      const relativePath = path.relative(routesDir, dir);
      const outputPaths = outDirs.map((outDir) => path.resolve(outDir, file));
      const fileContent = generateFileContent(relativePath, file);

      // Write the file to each output directory and create all necessary folders
      outputPaths.forEach((outputPath) => {
        const outputDir = path.dirname(outputPath);
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(outputPath, fileContent, { encoding: "utf8" });
      });
    }
  });
}

syncRoutes(routesDir, pagesDirs);
